// Generated by CoffeeScript 1.4.0
var Actor, CanvasRendererComponent, CyanGhost, Direction, GameMode, Ghost, KeyboardInputComponent, Kovas, Map, OrangeGhost, PinkGhost, Player, RedGhost, Scorer, Tile,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

window.requestAnimationFrame = (function() {
  return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.msRequestAnimationFrame || window.oRequestAnimationFrame || function(f) {
    return window.setTimeout(f, 1e3 / 60);
  };
})();

document.addEventListener('DOMContentLoaded', function() {
  var game;
  game = new Kovas({
    renderer: new CanvasRendererComponent(document.getElementById('kovas')),
    input: new KeyboardInputComponent
  });
  return game.run();
});

Array.prototype.sortBy = function(fun) {
  var i, j, js, jsn, _i, _j, _ref, _ref1, _ref2;
  for (i = _i = 0, _ref = this.length - 1; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
    for (j = _j = 0, _ref1 = (this.length - 1) - i; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; j = 0 <= _ref1 ? ++_j : --_j) {
      js = fun(this[j]);
      jsn = fun(this[j + 1]);
      if (fun(this[j]) > fun(this[j + 1])) {
        _ref2 = [this[j + 1], this[j]], this[j] = _ref2[0], this[j + 1] = _ref2[1];
      }
    }
  }
  return this;
};

CanvasRendererComponent = (function() {

  function CanvasRendererComponent(element) {
    this.element = element;
    this.width = window.innerWidth;
    this.height = window.innerHeight;
    this.drawIntroState = 40;
  }

  CanvasRendererComponent.prototype.start = function() {
    this.canvas = document.createElement('canvas');
    this.canvas.width = this.width - 50;
    this.canvas.height = this.height - 50;
    this.ctx = this.canvas.getContext('2d');
    this.ctx.font = "normal 20px Share Tech Mono";
    return this.element.appendChild(this.canvas);
  };

  CanvasRendererComponent.prototype.drawScore = function(score) {
    this.ctx.save();
    this.ctx.translate(0, -20);
    this.ctx.fillStyle = '#fff';
    this.ctx.fillText("Score: " + score, 0, 0);
    return this.ctx.restore();
  };

  CanvasRendererComponent.prototype.drawLives = function(lives) {
    this.ctx.save();
    this.ctx.translate(0, -20);
    this.ctx.fillStyle = '#fff';
    this.ctx.fillText(Array(lives + 1).join("â™¥"), 500, 0);
    return this.ctx.restore();
  };

  CanvasRendererComponent.prototype.drawIntro = function() {
    if (this.drawIntroState > 0) {
      this.ctx.save();
      this.ctx.fillStyle = '#fff';
      this.ctx.fillText("Press SPACE to begin", 178, 295);
      return this.ctx.restore();
    }
  };

  CanvasRendererComponent.prototype.drawEmptyTile = function(x, y) {
    return true;
  };

  CanvasRendererComponent.prototype.drawWallTile = function(x, y) {
    this.ctx.save();
    this.ctx.fillStyle = '#00f';
    this.ctx.fillRect(x * 25, y * 25, 25, 25);
    return this.ctx.restore();
  };

  CanvasRendererComponent.prototype.drawFoodTile = function(x, y) {
    x = (x * 25) + 10;
    y = (y * 25) + 10;
    this.ctx.save();
    this.ctx.fillStyle = '#fff';
    this.ctx.fillRect(x, y, 5, 5);
    return this.ctx.restore();
  };

  CanvasRendererComponent.prototype.drawPlayer = function(x, y) {
    x *= 25;
    y *= 25;
    this.ctx.save();
    this.ctx.fillStyle = '#ff0';
    this.ctx.fillRect(x, y, 25, 25);
    return this.ctx.restore();
  };

  CanvasRendererComponent.prototype.drawGhost = function(x, y, colour) {
    x *= 25;
    y *= 25;
    this.ctx.save();
    this.ctx.fillStyle = colour;
    this.ctx.fillRect(x, y, 25, 25);
    return this.ctx.restore();
  };

  CanvasRendererComponent.prototype.clear = function() {
    this.drawIntroState -= 1;
    if (this.drawIntroState < -40) {
      this.drawIntroState = 40;
    }
    this.ctx.restore();
    this.ctx.clearRect(0, 0, this.width, this.height);
    this.ctx.save();
    return this.ctx.translate(0, 40);
  };

  return CanvasRendererComponent;

})();

KeyboardInputComponent = (function() {
  var MAPPING;

  MAPPING = {
    'left': 37,
    'right': 39,
    'down': 40,
    'up': 38,
    'space': 32
  };

  function KeyboardInputComponent() {
    this.keyUp = __bind(this.keyUp, this);

    this.keyDown = __bind(this.keyDown, this);
    true;
  }

  KeyboardInputComponent.prototype.start = function() {
    this.keys = [];
    window.onkeydown = this.keyDown;
    return window.onkeyup = this.keyUp;
  };

  KeyboardInputComponent.prototype.isKeyDown = function(key) {
    return this.keys[MAPPING[key]];
  };

  KeyboardInputComponent.prototype.keyDown = function(e) {
    this.keys[e.keyCode] = true;
    if ((e.keyCode >= 37 && e.keyCode <= 40) || e.keyCode === 32) {
      return false;
    }
  };

  KeyboardInputComponent.prototype.keyUp = function(e) {
    return this.keys[e.keyCode] = false;
  };

  KeyboardInputComponent.prototype.moveLeft = function() {
    return this.isKeyDown('left');
  };

  KeyboardInputComponent.prototype.moveRight = function() {
    return this.isKeyDown('right');
  };

  KeyboardInputComponent.prototype.moveUp = function() {
    return this.isKeyDown('up');
  };

  KeyboardInputComponent.prototype.moveDown = function() {
    return this.isKeyDown('down');
  };

  KeyboardInputComponent.prototype.startGame = function() {
    return this.isKeyDown('space');
  };

  return KeyboardInputComponent;

})();

Tile = {
  empty: 0,
  wall: 1,
  food: 2
};

Map = (function() {
  var MAPS;

  MAPS = [
    {
      data: "#######################\n#..........#..........#\n#.###.####.#.####.###.#\n#.###.####.#.####.###.#\n#.....................#\n#.###.##.#####.##.###.#\n#......#...#...#......#\n######.###.#.###.######\n#....#...........#....#\n#.##.#.#### ####.#.##.#\n#.##.#.#       #.#.##.#\n#......#   g   #......#\n#.##.#.#       #.#.##.#\n#.##.#.#########.#.##.#\n#....#...........#....#\n######.###.#.###.######\n#......#...#...#......#\n#.###.##.#####.##.###.#\n#.....................#\n#.###.####.#.####.###.#\n#.###.####.#.####.###.#\n#..........#..........#\n#######################"
    }
  ];

  function Map(levelIndex) {
    this.levelIndex = levelIndex != null ? levelIndex : 0;
    this.tiles = {};
    this.width = 0;
    this.height = 0;
    this.remainingFood = 0;
    this._loadLevel(MAPS[this.levelIndex].data);
  }

  Map.prototype.tileType = function(x, y) {
    if (!this.isInBounds(x, y)) {
      return void 0;
    }
    return this.tiles[y][x];
  };

  Map.prototype.isInBounds = function(x, y) {
    return (x >= 0 && x <= this.width) && (y >= 0 && y <= this.height);
  };

  Map.prototype.eatFood = function(x, y) {
    this.remainingFood -= 1;
    return this.tiles[y][x] = Tile.empty;
  };

  Map.prototype._loadLevel = function(data) {
    var char, index, x, y, _base, _base1, _base2, _base3, _i, _len, _ref, _results;
    x = 0;
    y = 0;
    _ref = data.split('');
    _results = [];
    for (index = _i = 0, _len = _ref.length; _i < _len; index = ++_i) {
      char = _ref[index];
      if (char === "\n") {
        y += 1;
        _results.push(x = 0);
      } else {
        if (x > this.width) {
          this.width = x;
        }
        if (y > this.height) {
          this.height = y;
        }
        switch (char) {
          case ".":
            this.remainingFood += 1;
            (_base = this.tiles)[y] || (_base[y] = {});
            this.tiles[y][x] = Tile.food;
            _results.push(x += 1);
            break;
          case "#":
            (_base1 = this.tiles)[y] || (_base1[y] = {});
            this.tiles[y][x] = Tile.wall;
            _results.push(x += 1);
            break;
          case " ":
            (_base2 = this.tiles)[y] || (_base2[y] = {});
            this.tiles[y][x] = Tile.empty;
            _results.push(x += 1);
            break;
          case "g":
            (_base3 = this.tiles)[y] || (_base3[y] = {});
            this.tiles[y][x] = Tile.empty;
            this.ghostStartPosition = [x, y];
            _results.push(x += 1);
            break;
          default:
            throw "Don't know what to do with " + (char.charCodeAt(0)) + " " + char + "!";
        }
      }
    }
    return _results;
  };

  return Map;

})();

Direction = {
  left: 0,
  right: 1,
  up: 2,
  down: 3
};

Actor = (function() {

  function Actor(map) {
    var _ref;
    this.map = map;
    _ref = this.startPosition(), this.x = _ref[0], this.y = _ref[1];
    this.direction = this.startDirection();
    this.nextMoveIn = this.moveDelay();
    this.alive = true;
  }

  Actor.prototype.update = function() {
    var newPosition;
    this.nextMoveIn -= 1;
    if (this.nextMoveIn <= 0) {
      newPosition = this.newPosition(this.direction);
      if (newPosition) {
        this.x = newPosition[0], this.y = newPosition[1];
        this.nextMoveIn = this.moveDelay();
        return this.movedTile();
      }
    }
  };

  Actor.prototype.canMove = function(direction) {
    return this.newPosition(direction) !== void 0;
  };

  Actor.prototype.addToPosition = function(direction, amount) {
    var newX, newY;
    if (amount == null) {
      amount = 1;
    }
    newX = this.x;
    newY = this.y;
    switch (direction) {
      case Direction.left:
        newX -= amount;
        break;
      case Direction.right:
        newX += amount;
        break;
      case Direction.up:
        newY -= amount;
        break;
      case Direction.down:
        newY += amount;
    }
    return [newX, newY];
  };

  Actor.prototype.newPosition = function(direction) {
    var newX, newY, _ref;
    _ref = this.addToPosition(direction), newX = _ref[0], newY = _ref[1];
    if (this.map.tileType(newX, newY) !== Tile.wall) {
      return [newX, newY];
    } else {
      return void 0;
    }
  };

  Actor.prototype.movedTile = function() {
    return true;
  };

  Actor.prototype.die = function() {
    return this.alive = false;
  };

  Actor.prototype.respawn = function() {
    var _ref;
    this.alive = true;
    _ref = this.startPosition(), this.x = _ref[0], this.y = _ref[1];
    return this.direction = this.startDirection();
  };

  return Actor;

})();

Player = (function(_super) {

  __extends(Player, _super);

  function Player() {
    return Player.__super__.constructor.apply(this, arguments);
  }

  Player.prototype.moveLeft = function() {
    if (this.canMove(Direction.left)) {
      return this.direction = Direction.left;
    }
  };

  Player.prototype.moveRight = function() {
    if (this.canMove(Direction.right)) {
      return this.direction = Direction.right;
    }
  };

  Player.prototype.moveUp = function() {
    if (this.canMove(Direction.up)) {
      return this.direction = Direction.up;
    }
  };

  Player.prototype.moveDown = function() {
    if (this.canMove(Direction.down)) {
      return this.direction = Direction.down;
    }
  };

  Player.prototype.moveDelay = function() {
    return 20;
  };

  Player.prototype.startPosition = function() {
    return [1, 1];
  };

  Player.prototype.startDirection = function() {
    return Direction.down;
  };

  return Player;

})(Actor);

Ghost = (function(_super) {

  __extends(Ghost, _super);

  function Ghost(map, player) {
    this.map = map;
    this.player = player;
    Ghost.__super__.constructor.call(this, this.map);
  }

  Ghost.prototype.update = function() {
    var newPosition;
    this.nextMoveIn -= 1;
    if (this.nextMoveIn <= 0) {
      newPosition = this.newPosition(this.direction);
      if (newPosition) {
        this.x = newPosition[0], this.y = newPosition[1];
        this.nextMoveIn = this.moveDelay();
        return this.movedTile();
      }
    }
  };

  Ghost.prototype.movedTile = function() {
    var distances, target, x, y, _ref, _ref1, _ref2, _ref3;
    this.canMoveUp = this.direction !== Direction.down && this.canMove(Direction.up);
    this.canMoveLeft = this.direction !== Direction.right && this.canMove(Direction.left);
    this.canMoveDown = this.direction !== Direction.up && this.canMove(Direction.down);
    this.canMoveRight = this.direction !== Direction.left && this.canMove(Direction.right);
    target = this.getTarget();
    if (this.canMoveUp) {
      _ref = this.newPosition(Direction.up), x = _ref[0], y = _ref[1];
      this.upDistance = this.calculateDistance(x, y, target.x, target.y);
    } else {
      this.upDistance = Infinity;
    }
    if (this.canMoveLeft) {
      _ref1 = this.newPosition(Direction.left), x = _ref1[0], y = _ref1[1];
      this.leftDistance = this.calculateDistance(x, y, target.x, target.y);
    } else {
      this.leftDistance = Infinity;
    }
    if (this.canMoveDown) {
      _ref2 = this.newPosition(Direction.down), x = _ref2[0], y = _ref2[1];
      this.downDistance = this.calculateDistance(x, y, target.x, target.y);
    } else {
      this.downDistance = Infinity;
    }
    if (this.canMoveRight) {
      _ref3 = this.newPosition(Direction.right), x = _ref3[0], y = _ref3[1];
      this.rightDistance = this.calculateDistance(x, y, target.x, target.y);
    } else {
      this.rightDistance = Infinity;
    }
    distances = [
      {
        direction: Direction.up,
        distance: this.upDistance
      }, {
        direction: Direction.left,
        distance: this.leftDistance
      }, {
        direction: Direction.down,
        distance: this.downDistance
      }, {
        direction: Direction.right,
        distance: this.rightDistance
      }
    ];
    distances.sortBy(function(e) {
      return e.distance;
    });
    return this.direction = distances[0].direction;
  };

  Ghost.prototype.calculateDistance = function(x, y, tx, ty) {
    var dx, dy;
    dx = Math.abs(tx - x);
    dy = Math.abs(ty - y);
    return dx + dy;
  };

  Ghost.prototype.moveDelay = function() {
    return 30;
  };

  Ghost.prototype.startDirection = function() {
    return Math.floor(Math.random() * 2);
  };

  Ghost.prototype.startPosition = function() {
    var x, y, _ref;
    _ref = this.map.ghostStartPosition, x = _ref[0], y = _ref[1];
    return [x + Math.round((Math.random() * 2) - 1), y + Math.round((Math.random() * 2) - 1)];
  };

  Ghost.prototype.getTarget = function() {
    return this.player;
  };

  return Ghost;

})(Actor);

RedGhost = (function(_super) {

  __extends(RedGhost, _super);

  function RedGhost() {
    return RedGhost.__super__.constructor.apply(this, arguments);
  }

  RedGhost.prototype.colour = '#f00';

  RedGhost.prototype.chaseTarget = function() {
    return [0, 3];
  };

  return RedGhost;

})(Ghost);

PinkGhost = (function(_super) {

  __extends(PinkGhost, _super);

  function PinkGhost() {
    return PinkGhost.__super__.constructor.apply(this, arguments);
  }

  PinkGhost.prototype.colour = '#f9c';

  PinkGhost.prototype.getTarget = function() {
    var x, y, _ref;
    _ref = this.player.addToPosition(this.player.position, 4), x = _ref[0], y = _ref[1];
    return {
      x: x,
      y: y
    };
  };

  PinkGhost.prototype.moveDelay = function() {
    return 30;
  };

  PinkGhost.prototype.chaseTarget = function() {
    return [this.map.width, 3];
  };

  return PinkGhost;

})(Ghost);

CyanGhost = (function(_super) {

  __extends(CyanGhost, _super);

  function CyanGhost() {
    return CyanGhost.__super__.constructor.apply(this, arguments);
  }

  CyanGhost.prototype.colour = '#6ff';

  CyanGhost.prototype.getTarget = function() {
    var x, y, _ref;
    _ref = this.player.addToPosition(this.player.position, 6), x = _ref[0], y = _ref[1];
    return {
      x: x,
      y: y
    };
  };

  CyanGhost.prototype.moveDelay = function() {
    return 35;
  };

  CyanGhost.prototype.chaseTarget = function() {
    return [0, this.map.height - 3];
  };

  return CyanGhost;

})(Ghost);

OrangeGhost = (function(_super) {

  __extends(OrangeGhost, _super);

  function OrangeGhost() {
    return OrangeGhost.__super__.constructor.apply(this, arguments);
  }

  OrangeGhost.prototype.MODE_PLAYER = 0;

  OrangeGhost.prototype.MODE_CHASE = 1;

  OrangeGhost.prototype.colour = '#f93';

  OrangeGhost.prototype.getTarget = function() {
    var x, y, _ref;
    if (this.targeting_mode === this.MODE_PLAYER) {
      if (this.calculateDistance(this.x, this.y, this.player.x, this.player.y) < 8) {
        this.targeting_mode = this.MODE_CHASE;
      }
      return this.player;
    } else {
      _ref = this.chaseTarget(), x = _ref[0], y = _ref[1];
      if (this.calculateDistance(this.x, this.y, this.player.x, this.player.y) >= 8) {
        this.targeting_mode = this.MODE_PLAYER;
      }
      return {
        x: x,
        y: y
      };
    }
  };

  OrangeGhost.prototype.moveDelay = function() {
    return 40;
  };

  OrangeGhost.prototype.chaseTarget = function() {
    return [this.map.width, this.map.height - 3];
  };

  return OrangeGhost;

})(Ghost);

Scorer = (function() {

  function Scorer(map, player, ghosts, gameWinCallback, gameOverCallback) {
    this.map = map;
    this.player = player;
    this.ghosts = ghosts;
    this.gameWinCallback = gameWinCallback;
    this.gameOverCallback = gameOverCallback;
    this.score = 0;
    this.lives = 3;
  }

  Scorer.prototype.update = function() {
    var ghost, _i, _j, _len, _len1, _ref, _ref1;
    if (this.player.alive) {
      _ref = this.ghosts;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        ghost = _ref[_i];
        if (ghost.x === this.player.x && ghost.y === this.player.y) {
          return this.loseLife();
        }
      }
      if (this.map.tileType(this.player.x, this.player.y) === Tile.food) {
        this.map.eatFood(this.player.x, this.player.y);
        this.incrementScore();
      }
      if (this.map.remainingFood === 0) {
        return this.gameWinCallback();
      }
    } else {
      this.respawnDelay -= 1;
      if (this.respawnDelay === 0) {
        _ref1 = this.ghosts;
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          ghost = _ref1[_j];
          ghost.respawn();
        }
        return this.player.respawn();
      }
    }
  };

  Scorer.prototype.incrementScore = function() {
    return this.score += 10;
  };

  Scorer.prototype.loseLife = function() {
    this.lives -= 1;
    this.player.die();
    this.respawnDelay = 60 * 3;
    if (this.lives === 0) {
      return this.gameOverCallback();
    }
  };

  return Scorer;

})();

GameMode = {
  intro: 0,
  play: 1,
  won: 2,
  lost: 3
};

Kovas = (function() {

  function Kovas(options) {
    this.options = options;
    this.update = __bind(this.update, this);

    this.gameOver = __bind(this.gameOver, this);

    this.gameWin = __bind(this.gameWin, this);

    true;
  }

  Kovas.prototype.run = function() {
    this.mode = GameMode.intro;
    this.map = new Map();
    this.ghosts = [];
    this.options.input.start();
    this.options.renderer.start();
    return window.requestAnimationFrame(this.update);
  };

  Kovas.prototype.gameStart = function() {
    if (this.map.remainingFood === 0) {
      this.map = new Map();
    }
    this.player = new Player(this.map);
    this.ghosts = [new RedGhost(this.map, this.player), new PinkGhost(this.map, this.player), new CyanGhost(this.map, this.player), new OrangeGhost(this.map, this.player)];
    this.scorer = new Scorer(this.map, this.player, this.ghosts, this.gameWin, this.gameOver);
    return this.mode = GameMode.play;
  };

  Kovas.prototype.gameWin = function() {
    return this.mode = GameMode.won;
  };

  Kovas.prototype.gameOver = function() {
    return this.mode = GameMode.lost;
  };

  Kovas.prototype.update = function() {
    var ghost, x, y, _i, _j, _k, _l, _len, _len1, _ref, _ref1, _ref2, _ref3;
    if (this.mode === GameMode.play) {
      if (this.options.input.moveLeft()) {
        this.player.moveLeft();
      }
      if (this.options.input.moveRight()) {
        this.player.moveRight();
      }
      if (this.options.input.moveUp()) {
        this.player.moveUp();
      }
      if (this.options.input.moveDown()) {
        this.player.moveDown();
      }
      this.player.update();
      this.scorer.update();
    }
    _ref = this.ghosts;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      ghost = _ref[_i];
      ghost.update();
    }
    this.options.renderer.clear();
    if (this.scorer) {
      this.options.renderer.drawScore(this.scorer.score);
      this.options.renderer.drawLives(this.scorer.lives);
    }
    for (y = _j = 0, _ref1 = this.map.height; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; y = 0 <= _ref1 ? ++_j : --_j) {
      for (x = _k = 0, _ref2 = this.map.width; 0 <= _ref2 ? _k <= _ref2 : _k >= _ref2; x = 0 <= _ref2 ? ++_k : --_k) {
        switch (this.map.tileType(x, y)) {
          case Tile.empty:
            this.options.renderer.drawEmptyTile(x, y);
            break;
          case Tile.wall:
            this.options.renderer.drawWallTile(x, y);
            break;
          case Tile.food:
            this.options.renderer.drawFoodTile(x, y);
        }
      }
    }
    if (this.player && this.player.alive) {
      this.options.renderer.drawPlayer(this.player.x, this.player.y);
    }
    _ref3 = this.ghosts;
    for (_l = 0, _len1 = _ref3.length; _l < _len1; _l++) {
      ghost = _ref3[_l];
      this.options.renderer.drawGhost(ghost.x, ghost.y, ghost.colour);
    }
    if (this.mode !== GameMode.play) {
      this.options.renderer.drawIntro();
      if (this.options.input.startGame()) {
        this.gameStart();
      }
    }
    return window.requestAnimationFrame(this.update);
  };

  return Kovas;

})();
